<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris</title>
<style>
  :root{--bg:#06111a;--panel:#0f1720;--muted:#9aa4b2;--accent:#e2e8f0}
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--accent);display:flex;align-items:center;justify-content:center}
  .wrap{display:flex;gap:20px;align-items:flex-start;padding:20px}
  .hud{width:220px;background:var(--panel);padding:14px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.6)}
  .hud h1{margin:0 0 10px;font-size:18px;text-align:center}
  .stat{display:flex;justify-content:space-between;margin:6px 0;font-size:14px}
  canvas{background:#07151a;border-radius:6px;image-rendering:pixelated;box-shadow:0 8px 24px rgba(0,0,0,.6)}
  .small{font-size:13px;color:var(--muted);margin-top:8px}
  button{background:#1f2937;color:var(--accent);border:0;padding:8px 10px;border-radius:6px;cursor:pointer;width:100%}
  .row{display:flex;gap:10px;align-items:center}
  .next-wrap{display:flex;gap:10px;align-items:center;margin-top:8px}
  .next-canvas{width:80px;height:80px;border-radius:6px;background:#07121a;display:block}
  .kbd-config{margin-top:12px}
  .binding{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;background:#071821;border-radius:6px;margin:6px 0}
  .binding button{width:auto;padding:6px 8px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  .range{width:100%}
  .hint{font-size:12px;color:var(--muted);margin-top:10px;text-align:center}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);visibility:hidden;opacity:0;transition:opacity .15s}
  .overlay.show{visibility:visible;opacity:1}
  .modal{background:#07121a;padding:18px 20px;border-radius:10px;text-align:center}
  .modal h2{margin:0 0 8px;font-size:18px}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:12px}
  .muted{opacity:.8}
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <h1>TETRIS</h1>
    <div class="stat"><span>Score</span><strong id="score">0</strong></div>
    <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>
    <div class="stat"><span>Level</span><strong id="level">0</strong></div>

    <div class="next-wrap">
      <div>
        <label>Next</label>
        <canvas id="next" class="next-canvas" width="80" height="80"></canvas>
      </div>
      <div style="flex:1">
        <label>Sound Volume</label>
        <input id="volume" type="range" min="0" max="1" step="0.01" class="range" />
        <div class="small">Use keyboard or rebind below</div>
      </div>
    </div>

    <div class="kbd-config">
      <label>Key Bindings</label>
      <div class="binding"><div>Left</div><button data-action="left" class="bind-btn">←</button></div>
      <div class="binding"><div>Right</div><button data-action="right" class="bind-btn">→</button></div>
      <div class="binding"><div>Rotate CCW</div><button data-action="rotL" class="bind-btn">Q</button></div>
      <div class="binding"><div>Rotate CW</div><button data-action="rotR" class="bind-btn">W</button></div>
      <div class="binding"><div>Soft Drop</div><button data-action="down" class="bind-btn">↓</button></div>
      <div class="binding"><div>Hard Drop</div><button data-action="hard" class="bind-btn">Space</button></div>
      <div style="margin-top:8px">
        <button id="resetKeys">Reset Keys</button>
      </div>
    </div>

    <div style="margin-top:12px">
      <button id="restartBtn">Restart</button>
      <div class="hint">Move: arrows • Q/W: rotate • Space: hard drop</div>
    </div>
  </div>

  <canvas id="tetris" width="240" height="400"></canvas>
</div>

<div id="gameOver" class="overlay">
  <div class="modal">
    <h2>Game Over</h2>
    <p id="finalScore">Score: 0 • Lines: 0</p>
    <div class="controls">
      <button id="restartBtn2">Play Again</button>
    </div>
    <div class="small muted">Press <strong>Enter</strong> to restart</div>
  </div>
</div>

<script>
/* ---------- Tetris with next-piece, sound (WebAudio), and keyboard-config ---------- */

/* ---------- Audio helper (no external files) ---------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
let masterGain = audioCtx.createGain();
masterGain.connect(audioCtx.destination);
masterGain.gain.value = 0.25; // default volume
document.getElementById('volume').value = masterGain.gain.value;

/* simple beep: freq, type, duration(ms), gain */
function beep(freq=440, type='sine', time=0.06, vol=0.2){
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(masterGain);
  o.start(t);
  o.stop(t + time);
}

/* melodic little effect for line clear */
function chordClear(){
  beep(660,'sine',0.05,0.14);
  setTimeout(()=>beep(880,'sine',0.05,0.12),55);
  setTimeout(()=>beep(1100,'sine',0.05,0.1),110);
}

/* ---------- Canvas setup ---------- */
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
ctx.scale(20,20);
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');
nctx.scale(20,20);

/* HUD elements */
const scoreEl = document.getElementById('score');
const linesEl = document.getElementById('lines');
const levelEl = document.getElementById('level');
const overlay = document.getElementById('gameOver');
const finalScore = document.getElementById('finalScore');
document.getElementById('restartBtn').onclick = restart;
document.getElementById('restartBtn2').onclick = restart;

/* ---------- Game model ---------- */
function createMatrix(w,h){ const m=[]; while(h--) m.push(new Array(w).fill(0)); return m; }
function createPiece(type){
  switch(type){
    case 'T': return [[0,0,0],[1,1,1],[0,1,0]];
    case 'O': return [[2,2],[2,2]];
    case 'L': return [[0,3,0],[0,3,0],[0,3,3]];
    case 'J': return [[0,4,0],[0,4,0],[4,4,0]];
    case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
    case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
    case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
  }
}
let colors = [null,'#7c3aed','#fbbf24','#f97316','#2563eb','#06b6d4','#10b981','#ef4444'];
let arena = createMatrix(12,20);
let player = {pos:{x:0,y:0}, matrix:null};
let nextPiece = null;

/* scoring / timing */
let dropCounter = 0;
let baseDropInterval = 1000;
let dropInterval = baseDropInterval;
let lastTime = 0;
let score = 0, lines = 0, level = 0;
let running = true;

/* ---------- Drawing ---------- */
function drawMatrix(matrix, offset, context=ctx){
  matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val){
        context.fillStyle = colors[val];
        context.fillRect(x+offset.x, y+offset.y, 1,1);
        context.strokeStyle = 'rgba(0,0,0,0.15)';
        context.lineWidth = 0.03;
        context.strokeRect(x+offset.x, y+offset.y, 1,1);
      }
    });
  });
}

function draw(){
  ctx.fillStyle = '#07151a';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(arena, {x:0,y:0});
  drawMatrix(player.matrix, player.pos);
  drawNext();
}

function drawNext(){
  nctx.fillStyle = '#07121a';
  nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  if(!nextPiece) return;
  // center next piece in 4x4 area
  const padX = Math.max(0, Math.floor((4-nextPiece[0].length)/2));
  const padY = Math.max(0, Math.floor((4-nextPiece.length)/2));
  drawMatrix(nextPiece, {x:padX, y:padY}, nctx);
}

/* ---------- Collisions & merge ---------- */
function collide(arena, player){
  const [m,o] = [player.matrix, player.pos];
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x] !== 0 &&
         (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val) arena[y+player.pos.y][x+player.pos.x] = val;
    });
  });
}

/* ---------- Rotation ---------- */
function rotate(matrix, dir){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row=>row.reverse());
  else matrix.reverse();
}

function playerRotate(dir){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while(collide(arena, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(offset > player.matrix[0].length){
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
  beep(880,'square',0.04,0.06); // rotate sound
}

/* ---------- Sweep lines ---------- */
function arenaSweep(){
  let rowCount = 0;
  outer: for(let y=arena.length-1;y>=0;--y){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x] === 0) continue outer;
    }
    const removed = arena.splice(y,1)[0].fill(0);
    arena.unshift(removed);
    y++;
    rowCount++;
  }
  if(rowCount){
    const points = [0,40,100,300,1200];
    score += points[rowCount] * (level+1);
    lines += rowCount;
    const newLevel = Math.floor(lines / 10);
    if(newLevel > level){
      level = newLevel;
      dropInterval = Math.max(100, baseDropInterval - level * 75);
    }
    // sound by rows
    if(rowCount === 1) beep(880,'sine',0.08,0.12);
    else chordClear();
    updateHUD();
  }
}

/* ---------- Player actions ---------- */
function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    spawnFromNext();
    arenaSweep();
    if(gameOverCheck()) endGame();
    beep(200,'sawtooth',0.02,0.06); // lock sound
  }
  dropCounter = 0;
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena, player)) player.pos.x -= dir;
  else beep(440,'sine',0.03,0.06); // move sound
}

/* ---------- Next piece & spawn ---------- */
function randPieceChar(){
  const pieces = 'TJLOSZI';
  return pieces[Math.floor(Math.random()*pieces.length)];
}

function generateNext(){
  nextPiece = createPiece(randPieceChar());
}

function spawnFromNext(){
  if(!nextPiece) generateNext();
  player.matrix = nextPiece;
  player.pos.y = 0;
  player.pos.x = Math.floor(arena[0].length/2 - player.matrix[0].length/2);
  generateNext();
  drawNext();
}

/* ---------- Game over ---------- */
function gameOverCheck(){
  return arena[0].some(c=>c!==0);
}
function endGame(){
  running = false;
  overlay.classList.add('show');
  finalScore.textContent = `Score: ${score} • Lines: ${lines} • Level: ${level}`;
  chordClear(); // celebratory chord slightly different
  beep(150,'sawtooth',0.4,0.08);
}

/* ---------- Restart ---------- */
function restart(){
  // resume audio on user gesture (some browsers require)
  if(audioCtx.state === 'suspended') audioCtx.resume();
  arena = createMatrix(12,20);
  score = 0; lines = 0; level = 0;
  baseDropInterval = 1000;
  dropInterval = baseDropInterval;
  dropCounter = 0;
  player = {pos:{x:0,y:0}, matrix:null};
  overlay.classList.remove('show');
  generateNext();
  spawnFromNext();
  updateHUD();
  running = true;
  lastTime = 0;
  requestAnimationFrame(update);
}

/* ---------- HUD ---------- */
function updateHUD(){
  scoreEl.textContent = score;
  linesEl.textContent = lines;
  levelEl.textContent = level;
}

/* ---------- Main loop ---------- */
function update(time = 0){
  if(!running) return;
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

/* ---------- Keyboard config ---------- */
const defaultBindings = {
  left: 'ArrowLeft',
  right: 'ArrowRight',
  rotL: 'q',
  rotR: 'w',
  down: 'ArrowDown',
  hard: ' '
};

let bindings = loadBindings();
applyBindingLabels();

function loadBindings(){
  try{
    const raw = localStorage.getItem('tetris_bindings_v1');
    if(raw) return JSON.parse(raw);
  }catch(e){}
  return Object.assign({}, defaultBindings);
}

function saveBindings(){
  localStorage.setItem('tetris_bindings_v1', JSON.stringify(bindings));
}

function applyBindingLabels(){
  document.querySelectorAll('.bind-btn').forEach(btn=>{
    const action = btn.getAttribute('data-action');
    btn.textContent = prettyKey(bindings[action] || defaultBindings[action]);
  });
}

/* pretty display for space */
function prettyKey(k){
  if(!k) return '?';
  if(k === ' ') return 'Space';
  if(k.startsWith('Arrow')) return k.replace('Arrow','←').replace('Left','Left').replace('Right','Right').replace('Up','Up').replace('Down','Down');
  return k.length === 1 ? k.toUpperCase() : k;
}

/* binding UI behavior */
document.querySelectorAll('.bind-btn').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const action = btn.getAttribute('data-action');
    btn.textContent = 'Press key...';
    await waitForKeyPress().then(key=>{
      bindings[action] = key;
      saveBindings();
      applyBindingLabels();
    }).catch(()=>{ applyBindingLabels(); });
  });
});

document.getElementById('resetKeys').addEventListener('click', ()=>{
  bindings = Object.assign({}, defaultBindings);
  saveBindings();
  applyBindingLabels();
});

/* wait for next key press */
function waitForKeyPress(){
  return new Promise((resolve, reject)=>{
    function onKey(e){
      e.preventDefault();
      const key = e.key;
      cleanup();
      resolve(key);
    }
    function onBlur(){ cleanup(); reject(); }
    function cleanup(){
      window.removeEventListener('keydown', onKey);
      window.removeEventListener('blur', onBlur);
    }
    window.addEventListener('keydown', onKey);
    window.addEventListener('blur', onBlur);
  });
}

/* ---------- Key handling (uses current bindings) ---------- */
document.addEventListener('keydown', e=>{
  // restart when overlay visible
  if(!running && e.key === 'Enter'){ restart(); return; }
  if(!running) return;

  // map actions
  for(const action in bindings){
    const key = bindings[action];
    if(key === e.key){
      handleAction(action);
      e.preventDefault();
      return;
    }
    // support ArrowKey display mapping too
    if(key === 'ArrowLeft' && e.key === 'ArrowLeft'){ handleAction(action); e.preventDefault(); return; }
    if(key === 'ArrowRight' && e.key === 'ArrowRight'){ handleAction(action); e.preventDefault(); return; }
    if(key === 'ArrowDown' && e.key === 'ArrowDown'){ handleAction(action); e.preventDefault(); return; }
  }

  // always allow default WASD/QW etc
  if(e.key === 'ArrowLeft') handleAction('left');
  else if(e.key === 'ArrowRight') handleAction('right');
  else if(e.key === 'ArrowDown') handleAction('down');
  else if(e.key === 'q') handleAction('rotL');
  else if(e.key === 'w') handleAction('rotR');
  else if(e.key === ' ') { handleAction('hard'); }
});

function handleAction(action){
  if(action === 'left') playerMove(-1);
  else if(action === 'right') playerMove(1);
  else if(action === 'rotL') playerRotate(-1);
  else if(action === 'rotR') playerRotate(1);
  else if(action === 'down') playerDrop();
  else if(action === 'hard'){
    // hard drop implementation
    while(!collide(arena, player)){ player.pos.y++; }
    player.pos.y--;
    merge(arena, player);
    spawnFromNext();
    arenaSweep();
    if(gameOverCheck()) endGame();
    dropCounter = 0;
    beep(520,'square',0.02,0.12);
  }
}

/* ---------- Volume control ---------- */
const volSlider = document.getElementById('volume');
volSlider.addEventListener('input', e=>{
  masterGain.gain.value = Number(e.target.value);
});

/* ---------- Initialize / start ---------- */
generateNext();
spawnFromNext();
updateHUD();
requestAnimationFrame(update);

/* ---------- small helper sounds for clicks (UI) ---------- */
document.querySelectorAll('button').forEach(b=>{
  b.addEventListener('click', ()=>{ beep(660,'triangle',0.05,0.06); });
});

/* ---------- Resume audio on first interaction because browsers block autoplay audio ---------- */
window.addEventListener('pointerdown', function once(){
  if(audioCtx.state === 'suspended') audioCtx.resume();
  window.removeEventListener('pointerdown', once);
});

/* ------------------------------------------------------------------ */
</script>
</body>
</html>